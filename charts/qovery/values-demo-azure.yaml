services:
  qovery:
    qovery-cluster-agent:
      enabled: true
    qovery-shell-agent:
      enabled: true
    qovery-engine:
      enabled: true
    qovery-priority-class:
      enabled: true
  ingress:
    ingress-nginx:
      enabled: true
  dns:
    external-dns:
      enabled: true
  logging:
    loki:
      enabled: true
    promtail:
      enabled: true
  certificates:
    cert-manager:
      enabled: true
    cert-manager-configs:
      enabled: true
    qovery-cert-manager-webhook:
      enabled: true
  observability: {}
  aws:
    q-storageclass-aws:
      enabled: false
    aws-ebs-csi-driver:
      enabled: false
    aws-load-balancer-controller:
      enabled: false
  gcp:
    q-storageclass-gcp:
      enabled: false
  scaleway:
    q-storageclass-scaleway:
      enabled: false
  azure:
    q-storageclass-azure:
      enabled: true
qovery:
  clusterId: &clusterId set-by-customer
  clusterShortId: &clusterShortId set-by-customer
  organizationId: &organizationId set-by-customer
  jwtToken: &jwtToken set-by-customer
  rootDomain: &rootDomain set-by-customer
  domain: &domain set-by-customer
  domainWildcard: &domainWildcard set-by-customer
  qoveryDnsUrl: &qoveryDnsUrl set-by-customer
  agentGatewayUrl: &agentGatewayUrl set-by-customer
  engineGatewayUrl: &engineGatewayUrl set-by-customer
  lokiUrl: &lokiUrl set-by-customer
  promtailLokiUrl: &promtailLokiUrl set-by-customer
  acmeEmailAddr: &acmeEmailAddr set-by-customer
  externalDnsPrefix: &externalDnsPrefix set-by-customer
  architectures: &architectures set-by-customer
  engineVersion: &engineVersion set-by-customer
  shellAgentVersion: &shellAgentVersion set-by-customer
  clusterAgentVersion: &clusterAgentVersion set-by-customer
qovery-cluster-agent:
  fullnameOverride: qovery-shell-agent
  image:
    tag: *clusterAgentVersion
  environmentVariables:
    CLUSTER_ID: *clusterId
    CLUSTER_JWT_TOKEN: *jwtToken
    GRPC_SERVER: *agentGatewayUrl
    LOKI_URL: *lokiUrl
    ORGANIZATION_ID: *organizationId
  useSelfSignCertificate: true
qovery-shell-agent:
  fullnameOverride: qovery-shell-agent
  image:
    tag: *shellAgentVersion
  environmentVariables:
    CLUSTER_ID: *clusterId
    CLUSTER_JWT_TOKEN: *jwtToken
    GRPC_SERVER: *agentGatewayUrl
    ORGANIZATION_ID: *organizationId
qovery-engine:
  image:
    tag: *engineVersion
  engineResources: null
  buildContainer:
    environmentVariables:
      BUILDER_CPU_ARCHITECTURES: *architectures
      BUILDER_ROOTLESS_ENABLED: 'true'
  environmentVariables:
    CLUSTER_ID: *clusterId
    CLUSTER_JWT_TOKEN: *jwtToken
    DOCKER_HOST: tcp://0.0.0.0:2375
    GRPC_SERVER: *engineGatewayUrl
    LIB_ROOT_DIR: /home/qovery/lib
    ORGANIZATION_ID: *organizationId
ingress-nginx:
  controller:
    useComponentLabel: true
    admissionWebhooks:
      enabled: true # set-by-customer
    allowSnippetAnnotations: true
    # enable if you want metrics scrapped by prometheus
    metrics:
      enabled: true # set-by-customer
      serviceMonitor:
        enabled: false # set-by-customer
    config:
      # set global default file size limit to 100m
      proxy-body-size: 100m
      # hide Nginx version
      server-tokens: "false"
      # annotation risk level - needed because of nginx.ingress.kubernetes.io/configuration-snippet in ingress configuration
      annotations-risk-level: "Critical"
      # enable real IP (client IP)
      enable-real-ip: "false" # set-by-customer
      # passes the incoming X-Forwarded-* headers to upstreams
      use-forwarded-headers: "false" # set-by-customer
      # append the remote address to the X-Forwarded-For header instead of replacing it
      compute-full-forwarded-for: "false" # set-by-customer
      # customize http-snippet
      http-snippet: |
          # Qovery: declare variables with safe defaults
          map $host $qovery_com_associated_service_id  { default ""; }
          map $host $qovery_com_environment_id         { default ""; }
      # customize log-format / set-by-customer
      # default format can be found in the template: https://github.com/nginxinc/kubernetes-ingress/blob/v3.5.2/internal/configs/version1/nginx.tmpl#L44
      # nginx_controller_log_format_upstream can be a json that why we pass it in the value file
      log-format-escaping-json: "true"
      log-format-escaping-none: "false" # set-by-customer
      limit-req-status-code: "503" # set-by-customer
    # PDB
    maxUnavailable: 20%
    ingressClassResource:
      # -- Name of the IngressClass
      name: nginx-qovery
      # -- Create the IngressClass or not
      enabled: true
    # the Ingress Class name to be used by Ingresses (use "nginx-qovery" for Qovery application/container deployments)
    ingressClass: nginx-qovery
    extraArgs:
      # Kubernetes path of the default Cert-manager TLS certificate (if used)
      default-ssl-certificate: "qovery/letsencrypt-acme-qovery-cert"
    updateStrategy:
      rollingUpdate:
        # set the minimum acceptable number of unavailable pods during a rolling update
        maxSurge: 1
        maxUnavailable: 0
    readinessProbe:
      initialDelaySeconds: 15
    # enable auoscaling if you want to scale the number of replicas based on CPU usage
    autoscaling:
      enabled: false # set-by-customer
      minReplicas: 2 # set-by-customer
      maxReplicas: 25 # set-by-customer
      targetCPUUtilizationPercentage: 50 # set-by-customer
    # required if you rely on a load balancer
    # the controller mirrors the address of this service's endpoints to the load-balancer status of all Ingress objects it satisfies.
    publishService:
      enabled: true
    # set a load balancer if you want your Nginx to be publicly accessible
    service:
      enabled: true
      annotations:
        # Qovery managed DNS requieres *.$domain (something like: *.<cluster_id>.<given_dns_name>)
        external-dns.alpha.kubernetes.io/hostname: *domainWildcard
      externalTrafficPolicy: "Local"
      sessionAffinity: ""
      healthCheckNodePort: 0
    # force a connection for 30 seconds before shutting down, to avoid exiting too early
    # and let time to AWS LB to catchup change in the topology
    # When /wait-shutdown is called, the LB healthcheck /healthz endpoint return an error, but nginx keep processing request
    lifecycle:
      preStop:
        exec:
          command:
            - sh
            - -c
            - (sleep 30 | nc localhost 80)&  sleep 1 ; /wait-shutdown
    topologySpreadConstraints:
      - labelSelector:
          matchLabels:
            app.kubernetes.io/instance: nginx-ingress
            app.kubernetes.io/component: controller
        topologyKey: kubernetes.io/hostname
        maxSkew: 1
        whenUnsatisfiable: DoNotSchedule
  
external-dns:
  fullnameOverride: external-dns
  # We have only 1 instance of external-dns, so creating pdb benefits nothing and may create unnecessary constraints
  # i.e: Karpenter will take them into account
  pdb:
    create: false
  # Make external DNS ignore this ingress https://github.com/kubernetes-sigs/external-dns/issues/1910#issuecomment-976371247
  annotationFilter: "external-dns.alpha.kubernetes.io/exclude notin (true)"
  # set domainFilters to the domain you want to manage
  domainFilters: [*rootDomain]
  triggerLoopOnEvent: true
  policy: sync
  # avoid dns collision with other external-dns instances
  txtOwnerId: *clusterShortId
  txtPrefix: *externalDnsPrefix
  # set the number of replicas you want to use
  replicas: 1
  # set the rolling update strategy you want to apply
  updateStrategy:
    type: RollingUpdate
  # remove if you don't want to use a custom image
  image:
    repository: public.ecr.aws/r3m4q3r9/pub-mirror-external-dns
  # set the provider to use (pdns for Qovery DNS demo)
  provider:
    name: pdns
  # Configure PDNS provider
  # pdns-server: environment variable with port concatenation
  # pdns-api-key: environment variable containing the API key
  extraArgs:
    pdns-server: "$(QOVERY_DNS_URL):443"
    pdns-api-key: "$(PDNS_API_KEY)"
  # Environment variables reference YAML anchors from values.yaml qovery: section
  env:
    - name: QOVERY_DNS_URL
      value: *qoveryDnsUrl
    - name: PDNS_API_KEY
      value: *jwtToken
  # set resources
  resources:
    limits:
      cpu: 50m
      memory: 100Mi
    requests:
      cpu: 50m
      memory: 100Mi
  
promtail:
  fullnameOverride: promtail
  namespace: qovery
  priorityClassName: qovery-high-priority
  config:
    clients:
      - url: *promtailLokiUrl
    snippets:
      extraRelabelConfigs:
        - action: labelmap
          regex: __meta_kubernetes_pod_label_(qovery_com_service_id|qovery_com_service_type|qovery_com_environment_id)
  # GCP only allows /var/log/xxx to be mounted as hostPath
  defaultVolumes:
    - hostPath:
        path: /var/log/pods
      name: pods
    - emptyDir: {}
      name: run
  defaultVolumeMounts:
    - mountPath: /var/log/pods
      name: pods
      readOnly: true
    - mountPath: /run/promtail
      name: run
loki:
  fullnameOverride: loki
  loki:
    auth_enabled: false
    ingester:
      lifecycler:
        ring:
          kvstore:
            store: inmemory
          replication_factor: 1
    schemaConfig:
      configs:
        # set the schema for the index (2020 version can be deleted on a fresh install)
        - from: 2020-05-15
          store: boltdb-shipper
          object_store: set-by-customer
          schema: v11
          index:
            prefix: index_
            period: 24h
        - from: 2022-01-11
          store: boltdb-shipper
          object_store: set-by-customer
          schema: v12
          index:
            prefix: index_
            period: 24h
        - from: 2025-10-14
          store: tsdb
          object_store: set-by-customer
          schema: v13
          index:
            prefix: index_
            period: 24h
  monitoring:
    dashboards:
      enabled: false
    rules:
      enabled: false
    serviceMonitor:
      enabled: false
      metricsInstance:
        enabled: false
    selfMonitoring:
      enabled: false
      grafanaAgent:
        installOperator: false
    grafanaAgent:
      enabled: false
    lokiCanary:
      enabled: false
  test:
    enabled: false
  gateway:
    enabled: false
  singleBinary:
    replicas: 1
    persistence:
      enabled: false
    extraVolumes:
      - name: data
        emptyDir: {}
      - name: storage
        emptyDir: {}
    extraVolumeMounts:
      - name: data
        mountPath: /data
      - name: storage
        mountPath: /var/loki
  
cert-manager:
  fullnameOverride: cert-manager
  global:
    leaderElection:
      namespace: qovery
  installCRDs: true
  replicaCount: 1
  startupapicheck:
    jobAnnotations:
      helm.sh/hook: post-install,post-upgrade
    rbac:
      annotations:
        helm.sh/hook: post-install,post-upgrade
    serviceAccount:
      annotations:
        helm.sh/hook: post-install,post-upgrade
qovery-cert-manager-webhook:
  fullnameOverride: qovery-cert-manager-webhook
  certManager:
    namespace: qovery
    serviceAccountName: cert-manager
  secret:
    apiUrl: *qoveryDnsUrl
    apiKey: *jwtToken
cert-manager-configs:
  fullnameOverride: cert-manager-configs
  externalDnsProvider: pdns # Qovery DNS
  namespace: "qovery"
  managedDns: [*domain]
  acme:
    letsEncrypt:
      emailReport: *acmeEmailAddr
      # set the Let's Encrypt URL
      # Test: https://acme-staging-v02.api.letsencrypt.org/directory
      # Prod: 
      acmeUrl: https://acme-v02.api.letsencrypt.org/directory
  provider:
    pdns:
      apiPort: "443"
      apiUrl: *qoveryDnsUrl
      apiKey: *jwtToken
